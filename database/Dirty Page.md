## 脏页（Dirty Page）

脏页是一个 Linux 内核中的概念。因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，Linux 是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。

当我们对数据进行任何修改时，同样不会立即影响物理表。这是一个完成动作的循环。

  - 修改缓冲区缓存页面中的数据 - 称为“逻辑写入”。
  - 将相同的内容从缓冲区缓存写入物理表/磁盘，并将其记录在事务日志中 - 称为“物理写入”。

在缓冲区缓存中修改的页面称为“脏页面”。在物理写入中将脏页复制到磁盘。一旦对磁盘进行了数据修改过程，就会删除脏页。

### MySQL 的脏页

我们知道 InnoDB 采用 Write Ahead Log 策略来防止宕机数据丢失，即事务提交时，先写重做日志，再修改内存数据页，这样就产生了脏页。既然有重做日志保证数据持久性，查询时也可以直接从缓冲池页中取数据，那为什么还要刷新脏页到磁盘呢？如果重做日志可以无限增大，同时缓冲池足够大，能够缓存所有数据，那么是不需要将缓冲池中的脏页刷新到磁盘。但是，通常会有以下几个问题：

  - 服务器内存有限，缓冲池不够用，无法缓存全部数据
  - 重做日志无限增大成本要求太高
  - 宕机时如果重做全部日志恢复时间过长

事实上，当数据库宕机时，数据库不需要重做所有的日志，只需要执行上次刷入点之后的日志。这个点就叫做 Checkpoint，它解决了以上的问题：

  - 缩短数据库恢复时间
  - 缓冲池不够用时，将脏页刷新到磁盘
  - 重做日志不可用时，刷新脏页

重做日志被设计成可循环使用，当日志文件写满时，重做日志中对应数据已经被刷新到磁盘的那部分不再需要的日志可以被覆盖重用。

所以，当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。

平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。

### 脏页的触发

那么，什么情况会引发数据库的 flush 过程呢？

1. 第一种场景是 InnoDB 的 redo log 写满了，这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。
2. 第二种场景对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。
3. 第三种场景对应的就是 MySQL 认为系统“空闲”的时候。当然，MySQL忙起来可是会很快就能把redo log 记满的，所以要合理地安排时间，即使是忙的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。
4. 第四种场景对应的就是 MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。

接下来，你可以分析一下上面四种场景对性能的影响。

其中，第三种情况是属于 MySQL 空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前两种场景下的性能问题。

第一种是“redo log 写满了，要 flush 脏页”，这种情况是 InnoDB 要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为 0。

第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：

  - 第一种是 `还没有使用的`
  - 第二种是 `使用了并且是干净页`
  - 第三种是 `使用了并且是脏页`

InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。

而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。

所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：

  1. 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；
  2. 日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。

所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。

### InnoDB 刷脏页的控制策略

#### `innodb_io_capacity`

首先，你要正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快。`innodb_io_capacity ` 就是一个设置磁盘性能的参数。该值通常建议设置为磁盘的写 IOPS.

> 该参数在 MySQL 5.5 及后续版本才可以调整.

测试磁盘的IOPS:

```
fio -filename=/data/tmp/test_randrw -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest
```

>注意, 上面的 -filename 要指定具体的文件名, 千万不要指定分区, 否则会导致分区不可用, 需要重新格式化.
>innodb_io_capacity 一般参考 写能力的 IOPS
>
>innodb_io_capacity 设置过低导致的性能问题案例:
>MySQL 写入速度很慢, TPS很低, 但是数据库主机的 IO 压力并不大.

现在你知道了，InnoDB 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL “抖”了一下的原因。

当innodb_io_capacity 设置过小时, InnoDB 会认为磁盘性能差, 导致刷脏页很慢, 甚至比脏页生成速度还慢, 就会造成脏页累积, 影响查询和更新性能.

`innodb_io_capacity` 大小设置:

  - 配置小, 此时由于 InnoDB 认为你的磁盘性能差, 因此刷脏页频率会更高, 以此来确保内存中的脏页比例较少.
  - 配置大, InnoDB 认为磁盘性能好, 因此刷脏页频率会降低, 抖动的频率也会降低.

#### `innodb_max_dirty_pages_pct `

`innodb_max_dirty_pages_pct ` 指的是脏页比例上限(默认值是 75%), 内存中的脏页比例越是接近该值, 则 InnoDB 刷盘速度会越接近全力.

如何计算内存中的脏页比例:

```
show global status like 'Innodb_buffer_pool_pages%';
```
#### `innodb_flush_neighbors `

当刷脏页时, 若脏页旁边的数据页也是脏页, 则会连带刷新, 注意这个机制是会蔓延的.

当 `innodb_flush_neighbors=1` 时开启该机制, 默认是 1, 但在 MySQL 8.0 中默认值是 0.

由于机械硬盘时代的 IOPS 一般只有几百, 该机制可以有效减少很多随机 IO, 提高系统性能.

但在固态硬盘时代, 此时 IOPS 高达几千, 此时 IOPS 往往不是瓶颈, "只刷自己" 可以更快执行完查询操作, 减少 SQL 语句的响应时间.

### 如果Redo Log 设置太小

这里有一个案例:
>测试在做压力测试时, 刚开始 insert, update 很快, 但是一会就变慢且响应延迟很高.

出现这种情况大部分是因为 Redo Log 设置太小引起的.

因为此时 Redo Log 写满后需要将 checkpoint 前推, 此时需要刷脏页, 可能还会连坐(`innodb_flush_neighbors=1`), 数据库"抖"的频率变高.

其实此时内存的脏页比例可能还很低, 并没有充分利用到大内存优势, 此时需要频繁flush, 性能会变差.

同时, 如果 Redo Log 中存在 change buffer, 同样需要做相应的 merge 操作, 导致 change buffer 发挥不出作用.

### 引用
1. MySQL的刷脏页问题
2. MySQL中InnoDB脏页刷新机制Checkpoint
3. MySQL WAL(Write-Ahead Log)机制及脏页刷新
